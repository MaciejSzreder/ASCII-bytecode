<!DOCTYPE html>
<html>
	<head>
		<title>ASCII bytecode - prototype</title>
		<script src="machine.js"></script>
		<script>
			function tapeDecode(code)
			{
				return code.split('\n').map((row)=>parseInt(row.slice(0,8).padEnd(8, ' ').replaceAll(' ', '0').replaceAll('O', '1'),2));
			}

			function tapeEncode(data)
			{
				return data[0].map((value)=>value.toString(2).padStart(8,' ').replaceAll('0',' ').replaceAll('1','O')).join('\n');
			}

			function run()
			{
				const code = String.fromCharCode(...tapeDecode(document.getElementById`code`.value));
				const input = tapeDecode(document.getElementById`input`.value);
				const output = document.getElementById`output`;
				output.textContent=tapeEncode(Machine.executeForInput(code, [input]));
			}
		</script>
	</head>
	<body>
		<h1>ASCII bytecode - prototype</h1>
		<p>The main idea is to use ASCII code points as bytecode.</p>
		<h1>Interface</h1>
		<div>
			<label for="input">input:</label>
			<textarea id="input">
        
       O
      O 
      OO</textarea>
		</div>
		<div>
			<label for="code">code:</label>
			<textarea id="code">
 OO O  O
 OO OOOO</textarea>
		</div>
		<div>
			<label for="output">output:</label>
			<textarea disabled id="output"></textarea>
		</div>
		<button onclick="run()">Run</button>
		<h1>Instructions</h1>
		<table>
			<tr><th>ASCII code point</th><th>ASCII character/Unicode Control Picture</th><th>description</th><th>comments</th></tr>
			<tr><td>0</td><td>&#x2400;</td><td>sets instruction pointer register to 0</td><td>loops code</td></tr>
			<tr><td>9</td><td>&#x2409;</td><td>no operation</td><td>use for code formatting</td></tr>
			<tr><td>10</td><td>&#x240A;</td><td>no operation</td><td>use for code formatting</td></tr>
			<tr><td>32</td><td>&#x2420;</td><td>no operation</td><td>use for code formatting</td></tr>
			<tr><td>33</td><td>!</td><td>writes to accumulator 1 if its previous value was not 0</td><td>accumulator=!accumulator</td></tr>
			<tr><td>35</td><td>#</td><td>writes to accumulator numbers of set bits of accumulator</td></tr>
			<tr><td>36</td><td>$</td><td>writes accumulator low byte to memory pointed by data address register</td><td>memory[data_address_register]=accumulator</td></tr>
			<tr><td>37</td><td>%</td><td>modules (basing on floored division; x % 0 == 0) accumulator by register A bits</td><td>accumulator%=A</td></tr>
			<tr><td>38</td><td>&amp;</td><td>conjuncts corresponding accumulator bits with register A bits</td><td>accumulator&=A</td></tr>
			<tr><td>40</td><td>(</td><td>swaps data address and stack pointer registers values</td><td>data_address_register,stack_pointer_register=stack_pointer_register,data_address_register</td></tr>
			<tr><td>41</td><td>)</td><td>decreases data address register, then writes address of next instruction to memory pointed by data address register</td><td>memory[--data_address_register]=instruction_pointer_register<br/></td></tr>
			<tr><td>42</td><td>*</td><td>multiplies accumulator by register A value</td><td>accumulator*=A</td></tr>
			<tr><td>43</td><td>+</td><td>increases accumulator by register A value</td><td>accumulator+=A</td></tr>
			<tr><td>44</td><td>,</td><td>decreases data address register, then writes accumulator low byte to memory pointed by data address register</td><td>memory[--data_address_register]=accumulator&255</td></tr>
			<tr><td>45</td><td>-</td><td>decreases accumulator by register A value</td><td>accumulator-=A</td></tr>
			<tr><td>47</td><td>/</td><td>divides accumulator by register A value</td><td>accumulator/=A</td></tr>
			<tr><td>48</td><td>0</td><td>appends 0 into decimal accumulator value</td><td>accumulator=accumulator*10</td></tr>
			<tr><td>49</td><td>1</td><td>appends 1 into decimal accumulator value</td><td>accumulator=accumulator*10+1</td></tr>
			<tr><td>50</td><td>2</td><td>appends 2 into decimal accumulator value</td><td>accumulator=accumulator*10+2</td></tr>
			<tr><td>51</td><td>3</td><td>appends 3 into decimal accumulator value</td><td>accumulator=accumulator*10+3</td></tr>
			<tr><td>52</td><td>4</td><td>appends 4 into decimal accumulator value</td><td>accumulator=accumulator*10+4</td></tr>
			<tr><td>53</td><td>5</td><td>appends 5 into decimal accumulator value</td><td>accumulator=accumulator*10+5</td></tr>
			<tr><td>54</td><td>6</td><td>appends 6 into decimal accumulator value</td><td>accumulator=accumulator*10+6</td></tr>
			<tr><td>55</td><td>7</td><td>appends 7 into decimal accumulator value</td><td>accumulator=accumulator*10+7</td></tr>
			<tr><td>56</td><td>8</td><td>appends 8 into decimal accumulator value</td><td>accumulator=accumulator*10+8</td></tr>
			<tr><td>57</td><td>9</td><td>appends 9 into decimal accumulator value</td><td>accumulator=accumulator*10+9</td></tr>
			<tr><td>58</td><td>:</td><td>swaps accumulator higher byte with lower byte</td><td>accumulator=accumulator>>8|accumulator&lt;&lt;8</td></tr>
			<tr><td>59</td><td>;</td><td>enters comment mode: ignores instructions until next ;</td><td>use for commenting</td></tr>
			<tr><td>60</td><td>&lt;</td><td>if accumulator value is less than register A value, sets accumulator to 1, otherwise to 0</td><td>accumulator=accumulator&lt;A</td></tr>
			<tr><td>61</td><td>=</td><td>if accumulator value is equal to register A value, sets accumulator to 1, otherwise to 0</td><td>accumulator=accumulator==A</td></tr>
			<tr><td>62</td><td>&gt;</td><td>if accumulator value is greater than register A value, sets accumulator to 1, otherwise to 0</td><td>accumulator=accumulator&gt;A</td></tr>
			<tr><td>63</td><td>?</td><td>assigns to accumulator random number between (inclusive) old accumulator value and argument register value</td><td>accumulator=rand(accumulator, A)</td></tr>
			<tr><td>64</td><td>@</td><td>copies to accumulator value from memory pointed by data address register </td><td>A=memory[data_address_register]</td></tr>
			<tr><td>65</td><td>A</td><td>copies accumulator value into register A</td><td>A=accumulator</td></tr>
			<tr><td>66</td><td>B</td><td>copies accumulator value into register B</td><td>B=accumulator</td></tr>
			<tr><td>67</td><td>C</td><td>copies accumulator value into register C</td><td>C=accumulator</td></tr>
			<tr><td>68</td><td>D</td><td>copies accumulator value into <u>d</u>ata address register</td><td>data_address_register=accumulator</td></tr>
			<tr><td>69</td><td>E</td><td>copies accumulator value into register E</td><td>E=accumulator</td></tr>
			<tr><td>70</td><td>F</td><td>copies accumulator value into register F</td><td>F=accumulator</td></tr>
			<tr><td>71</td><td>G</td><td>copies accumulator value into register G</td><td>G=accumulator</td></tr>
			<tr><td>73</td><td>I</td><td>appends <u>1</u> into binary accumulator value</td><td>accumulator=accumulator*2+1</td></tr>
			<tr><td>74</td><td>J</td><td>copies accumulator value into instruction pointer register</td><td>use for <u>j</u>umps</td></tr>
			<tr><td>77</td><td>M</td><td>copies <u>m</u>ax value of register A and accumulator into accumulator</td><td>accumulator=max(accumulator,A)</td></tr>
			<tr><td>79</td><td>O</td><td>appends <u>0</u> into binary accumulator value</td><td>accumulator=accumulator*2</td></tr>
			<tr><td>80</td><td>P</td><td>copies accumulator value into <u>p</u>ort index register</td><td>use for I/O service</td></tr>
			<tr><td>83</td><td>S</td><td>copies 8th bit into each higher bit in accumulator</td><td>use to convert 8bit signed number to 16bit signed number</td></tr>
			<tr><td>88</td><td>X</td><td>copies accumulator value into register X</td><td>X=accumulator</td></tr>
			<tr><td>89</td><td>Y</td><td>copies core state to free core, except instruction pointer register, which have assigned accumulator value. Core starts processing.</td><td></td></tr>
			<tr><td>90</td><td>Z</td><td>copies accumulator value into register Z</td><td>Z=accumulator</td></tr>
			<tr><td>91</td><td>[</td><td>if accumulator is 0 ignores instruction until meeting corresponding ]</td><td>if(accumulator){code}</td></tr>
			<tr><td>92</td><td>\</td><td>divides accumulator by register A value</td><td>accumulator=A/accumulator</td></tr>
			<tr><td>93</td><td>]</td><td>closes if body opened by [</td><td>if(accumulator){code}</td></tr>
			<tr><td>94</td><td>^</td><td>xores corresponding accumulator bits with register A bits</td><td>accumulator^=A</td></tr>
			<tr><td>95</td><td>_</td><td>sets accumulator register to zero</td><td>accumulator=0</td></tr>
			<tr><td>96</td><td>`</td><td>copies to accumulator value from memory pointed by data address register, then increases data address register</td><td>accumulator=memory[data_address_register++]</td></tr>
			<tr><td>97</td><td>a</td><td>copies register A value into accumulator</td><td>accumulator=A</td></tr>
			<tr><td>98</td><td>b</td><td>copies register B value into accumulator</td><td>accumulator=B</td></tr>
			<tr><td>99</td><td>c</td><td>copies register C value into accumulator</td><td>accumulator=C</td></tr>
			<tr><td>100</td><td>d</td><td>copies <u>d</u>ata address register value into accumulator</td><td>accumulator=data_address_register</td></tr>
			<tr><td>101</td><td>e</td><td>copies register E value into accumulator</td><td>accumulator=E</td></tr>
			<tr><td>102</td><td>f</td><td>copies register F value into accumulator</td><td>accumulator=F</td></tr>
			<tr><td>103</td><td>g</td><td>copies register G value into accumulator</td><td>accumulator=G</td></tr>
			<tr><td>105</td><td>i</td><td>reads 8bit integer from <u>i</u>nput pointed by port register and stores it in the accumulator</td><td>accumulator=IO[P]&255</td></tr>
			<tr><td>106</td><td>j</td><td>copies instruction pointer register value into accumulator</td><td>use for <u>j</u>umps</td></tr>
			<tr><td>109</td><td>m</td><td>copies <u>m</u>in value of register A and accumulator into accumulator</td><td>accumulator=min(accumulator,A)</td></tr>
			<tr><td>111</td><td>o</td><td>write accumulator low byte to <u>o</u>utput pointed by port register as unsigned integer</td><td>IO[P]=accumulator&255</td></tr>
			<tr><td>112</td><td>p</td><td>copies <u>p</u>ort register value into accumulator</td><td>accumulator=P</td></tr>
			<tr><td>115</td><td>s</td><td>calculates sinus of angle in accumulator, where 0 means 0&deg;, 32768 means 90&deg;, and stores result reinterpreted as integer in accumulator</td><td>accumulator=round(sin(accumulator/32765*&pi;)*32767)</td></tr>
			<tr><td>120</td><td>x</td><td>copies register x value into accumulator</td><td>accumulator=X</td></tr>
			<tr><td>122</td><td>z</td><td>copies register Z value into accumulator</td><td>accumulator=Z</td></tr>
			<tr><td>123</td><td>{</td><td>opens loop body</td><td></td></tr>
			<tr><td>124</td><td>|</td><td>alternates corresponding accumulator bits with register A bits</td><td>accumulator|=A</td></tr>
			<tr><td>125</td><td>}</td><td>if accumulator is not 0, goes to corresponding {</td><td>do{code}while(accumulator)</td></tr>
			<tr><td>126</td><td>~</td><td>negates accumulator bits</td><td>accumulator=~accumulator</td></tr>
		</table>
	</body>
</html>